extern crate regex;
extern crate serde;
extern crate serde_json;

#[macro_use]
extern crate serde_derive;

use regex::Regex;
use std::{
  collections::{hash_map::Entry as HashEntry, HashMap, HashSet},
  fs::File,
  io,
  io::{prelude::*, BufReader, BufWriter},
  str,
};

#[derive(Serialize)]
struct WordlistForm(String, String);

#[derive(Serialize)]
struct Wordlist<'norm, 'deperm> {
  forms: HashMap<&'norm String, WordlistForm>,
  sets: HashMap<usize, HashMap<&'deperm String, Vec<&'norm String>>>,
}

type CharCounts = HashMap<char, usize>;

fn count_chars(s: &str) -> CharCounts {
  let mut ret = CharCounts::new();

  for c in s.chars() {
    match ret.entry(c) {
      HashEntry::Occupied(o) => {
        let mut val = o.into_mut();
        *val = *val + 1;
      }
      HashEntry::Vacant(v) => {
        v.insert(1);
      }
    }
  }

  ret
}

fn is_subseq(count: &CharCounts, of: &CharCounts) -> bool {
  count.iter().all(|(c, n)| n <= of.get(c).unwrap_or(&0))
}

fn main() {
  let min_valid_len = 3;
  let min_len = 5;
  let max_len = 8;

  let mut words = Vec::new();

  {
    let file = File::open("etc/wordlist.txt").expect("wordlist not found");
    let file = BufReader::new(&file);

    for line in file.lines() {
      let line = line.expect("failed to read line");

      words.push(line.trim().to_string());
    }
  }

  println!("read {} word(s)", words.len());

  // depermuted => [normalized]
  let mut permutations: HashMap<String, Vec<String>> = HashMap::new();
  // depermuted => count
  let mut counts: HashMap<&String, CharCounts> = HashMap::new();
  // len => [depermuted]
  let mut len_groups: HashMap<usize, Vec<&String>> = HashMap::new();
  // [depermuted]
  let mut valid_subwords: Vec<&String> = Vec::new();
  // [normalized]
  let mut used_words: HashSet<&String> = HashSet::new();

  let mut list = Wordlist {
    forms: HashMap::new(),
    sets: HashMap::new(),
  };

  let reject_re = Regex::new(r"[\d\s]").unwrap();
  let normal_re = Regex::new(r"\W+").unwrap();
  let blank_re = Regex::new(r"\w").unwrap();

  for word in words {
    if reject_re.is_match(&word) {
      continue;
    }

    let normalized = word.to_lowercase();
    let normalized = normal_re.replace_all(&normalized, "").into_owned();

    match list.forms.entry(&normalized) {
      HashEntry::Occupied(o) => {
        let val = o.get();
        println!(
          "WARNING: {} is a duplicate! ({} vs. {})",
          &normalized, &word, val.0
        );
      }
      HashEntry::Vacant(v) => {
        v.insert(WordlistForm(
          word.clone(),
          blank_re.replace_all(&word, "_").into_owned(),
        ));
      }
    }

    let mut depermuted: Vec<char> = normalized.chars().collect();
    depermuted.sort();
    let depermuted: String = depermuted.iter().collect();

    match permutations.entry(depermuted.clone()) {
      HashEntry::Occupied(o) => {
        o.into_mut().push(normalized);
      }
      HashEntry::Vacant(v) => {
        v.insert([normalized].to_vec());
        counts.insert(&depermuted, count_chars(&depermuted));

        match len_groups.entry(depermuted.len()) {
          HashEntry::Occupied(o) => {
            o.into_mut().push(&depermuted);
          }
          HashEntry::Vacant(v) => {
            v.insert([&depermuted].to_vec());
          }
        }

        if depermuted.len() >= min_valid_len {
          valid_subwords.push(&depermuted);
        }
      }
    };
  }

  println!("{} normalized", list.forms.len());
  println!("{} depermuted", permutations.len());
  println!("{} valid subword(s)", valid_subwords.len());

  for len in min_len..max_len + 1 {
    println!("queuing {}-letter words...", len);

    let mut sets: HashMap<&String, Vec<&String>> = HashMap::new();

    let iter = counts.iter().filter(|(d, _)| d.len() == len);

    let len = iter.clone().count();

    for (i, (depermuted, count)) in iter.enumerate() {
      print!("\r\x1b[2K({}/{}) {}", &i, &len, &depermuted);
      io::stdout().flush().unwrap();

      let mut list: Vec<&String> = valid_subwords
        .iter()
        .filter(|deperm2| {
          deperm2.len() <= depermuted.len()
            && is_subseq(&counts[*deperm2], &count)
        })
        .flat_map(|d| permutations[d].iter().map(|n| *n))
        .collect();

      list.sort();

      for norm in list.iter() {
        used_words.insert(norm);
      }

      sets.insert(depermuted, list);
    }

    print!("\r\x1b[2K");
    io::stdout().flush().unwrap();

    list.sets.insert(len, sets);
  }

  list.forms.retain(|k, _| used_words.contains(k));

  {
    let file = File::create("words.json").expect("couldn't create output file");
    let file = BufWriter::new(&file);

    serde_json::to_writer(file, &list).expect("failed to write JSON");
  }
}
